1. 서버(Server)
	• 클라이언트 - 서버 시스템(Client - Server System)의 서비스 과정.
		○ 클라이언트가 서버에게 서비스 요청.
		○ 서버는 요청에 응답하여 처리 수행.
		○ 서버는 처리 결과를 클라이언트에 반환.
		○ 클라이언트는 처리 결과를 받음.
	• 서버란 서비스 소프트웨어가 설치된 기기를 의미.
		○ 따라서 한 기기에 여러가지 서비스SW를 설치할 경우 여러가지 역할.
		○ 예) Apache, IIS, nginx와 같은 웹 서버SW가 설치되면 해당 기기는 웹 서버가 됨.
	• 서버의 종류가 많으므로, 사용자가 필요에 적합한 서버SW를 설치.
	• 서버의 운용 관리 - 서버 종료 전까지 진행되는 가장 긴 과정.
		○ 설정 변경
			§ 사용자의 요구에 맞춰 서버의 설정을 변경
		○ 트러블 대처
			§ 사전 대처와 사후 대처로 분류
			§ 사전 대처 : 서버의 각종 상태(CPU 사용률, 메모리 사용률, 통신 상태, 오류 로그)를 정기적으로 체크. 경우에 따라 서버 교체 등 실시.
			§ 사후 대처 : 서버에서 발생한 오류 지점을 LED나 오류 로그를 통해 확인. 장애 테스트에 대한 시뮬레이션해두는 것이 바람직.
	• 네트워크 : 서버와 클라이언트를 연결.

2. 네트워크 기초 지식
	• 서버는 무선 LAN을 사용하지 않음 - 무선 LAN은 아직까지 클라이언트를 위한 것.
	• 하위 계층에서 상위 계층으로 순차적 설명.
		○ 물리 계층 - 데이터 링크 계층 - 네트워크 계층 - 전송 계층 - 세션 계층 - 표현 계층 - 응용 계층
		○ 각 계층의 기술(프로토콜)적인 내용과 기기적인 내용을 설명. (예) L3의 기술인 IP, ARP 프로토콜과 기기인 라우터
	• OSI 7 Layer는 각 계층의 기능과 역할을 가지고 있으며, 각자 따로 작동하기 때문에 트러블이 발생했을 경우 어디서 문제가 발생했는지 파악 가능.
	• 프로토콜의 중요 역할 : 캡슐화 & 역캡슐화
		○ 서버는 상위 계층에서부터 하위 계층으로 캡슐화를 진행.
		○ 애플리케이션 데이터를 전송 계층으로 전달. 전송 계층에서 TCP/UDP Header를 추가하여 세그먼트 생성.
		○ 전송 계층 세그먼트를 네트워크 계층으로 전달. 네트워크 계층에서 IP Header를 추가하여 패킷 생성.
		○ 네트워크 계층의 패킷을 데이터링크 계층으로 전달. 데이터링크 계층에서 Ethernet Header를 추가하여 프레임 생성.
		○ 데이터링크 계층에서 프레임을 물리 계층으로 전달. 물리 계층에서 프레임을 비트로 변환하여 광 케이블로 전송.
		○ (클라이언트는 하위 계층에서부터 상위 계층으로 역캡슐화를 진행)
	• Ethernet & MAC 주소 & 스위치(Switch)
		○ 네트워크 계층에서 넘어온 IP Packet에 Ethernet Header가 추가되어 Ethernet Frame을 생성.
			§ Ethernet Header에는 MAC 출발지 주소, 목적지 주소 등이 포함. MAC 주소란 랜 카드 주소와 같은 물리적 주소.
		○ Ethernet Frame은 스위치라는 기기를 통해 경로 이동. 스위치에는 MAC Address Table이 존재.
	• IP & IP 주소 & 라우터(Router)
		○ 전송 계층에서 넘어온 TCP/UDP Segment에 IP Header가 추가되어 IP Packet을 생성.
			§ IP Header에는 Packet의 목적지를 나타내는 IP 주소가 포함. 
			§ IP 주소의 표기법.
		○ 라우터를 이용하여 패킷을 전송하고자하는 네트워크(Next Hop)로 전송.
			§ 라우터도 스위치와 동일하게 테이블이 존재.
			§ 라우팅 테이블 생성 : 정적 라우팅, 동적 라우팅. 비교.
	• ARP(Address Resolution Protocol)
		○ MAC 주소는 컴퓨터 NIC(Network Interface Card)에 새겨진 물리적 주소. IP 주소는 OS에서 설정하는 논리적 주소.
		○ ARP는 MAC과 IP주소를 대응시켜주는 프로토콜.
			§ 예) 데이터링크 계층에서 IP Packet을 이용하여 Ethernet Frame을 생성할 때, 출발지 MAC 주소는 자신의 NIC를 이용하여 생성할 수 있으나, 목적지 MAC 주소는 알 방법이 없음. 따라서 ARP로 IP 주소를 통해 MAC 주소를 파악.
			§ IP 주소를 비교하여 동일한 네트워크 내에 존재할 경우, ARP Request - ARP Reply(응답 결과 ARP 테이블 저장)를 통해 목적지 MAC 주소를 파악하여 Ethernet Frame 생성.
			§ IP 주소를 비교하였으나 동일한 네트워크 내에 존재하지 않을 경우, Default Gateway의 MAC 주소를 목적지로 하여 Ethernet Frame 생성.
		○ 컴퓨터 간 통신을 할 때, 통신 데이터의 IP 주소는 출발지부터 목적지까지 바뀌지 않지만, MAC 주소는 NIC이 변경될 때마다 변경.
	• TCP / UDP
		○ 애플리케이션 계층의 데이터가 전송 계층으로 전달되면 TCP 또는 UDP 헤더를 추가하여 TCP Segment 또는 UDP Datagram을 생성.
		○ TCP : 데이터의 신뢰성. 데이터 전송을 매번 확인하며 통신. 웹, 메일, 파일 공유 등 데이터를 누락시키고 싶지 않은 서비스에서 사용.
		○ UDP : 데이터의 신속성. 데이터 전송을 한 번하면 끝. VoIP(Voice over IP), 시간 동기, 스트리밍 등 속도가 필요한 서비스에서 사용.
		○ TCP/UDP는 포트 번호를 이용하여 컴퓨터 내 어떤 애플리케이션에 데이터를 전달하면 좋을지 식별.
			§ 포트 번호는 총 0~65535로 구성.
			§ 0~1023 : Well Known Port, 일반적인 서버 소프트웨어가 클라이언트 서비스를 요청 대기할 때 사용.
			§ 1024~49151 : Registered Port, 제조 업체의 독자적인 서버 소프트웨어가 클라이언트의 서비스 요청을 대기할 때.
			§ 49152~65535 : Dynamic Port, 서버가 클라이언트를 식별하기 위해 사용.
	• 포트 번호 식별법
		○ 포트 번호는 컴퓨터 안에서 작동하는 애플리케이션을 식별하기 위한 수단으로 사용.
		○ 웹 클라이언트가 웹 서버에 엑세스하는 경우 예시.
			§ Client To Server(Request)
			§ 웹 브라우저(L5~7)가 웹 데이터를 만들어서 웹 클라이언트에게 전달.
			§ 출발지 포트에 Dynamic Port 중 랜덤으로 숫자를 선택. 목적지 포트에 웹 서버를 나타내는 80을 넣어 UDP Segment 생성.
			§ 네트워크 계층 IP Header 캡슐화, 데이터링크 계층 Ethernet Header 캡슐화, 물리 계층 데이터 비트화 후 웹 서버로 전달.
			§ 서버에서 역캡슐화를 진행하여 목적지 포트 번호 80 확인. 80은 Well Known Number 이므로 웹 서버 SW 애플리케이션으로 전달. 
			§ Server To Client(Response)
			§ 웹 서버 SW(L5~7)는 Client의 Request를 수렴하여 알맞은 Response 생성하여 전송 계층으로 전달.
			§ 출발지 포트에 웹 서버를 나타내는 80. 목적지 포트에 웹 브라우저의 포트 번호를 대입.
			§ 캡슐화를 하여 웹 클라이언트로 전달.
			§ 웹 클라이언트 단에서 역캡슐화 진행 및 Response 확인. 
	• NAT / NAPT(Network Address Translation / Network Address Port Translation)
		○ 기업이나 가정의 LAN에서 사용하는 사설 IP 주소를 인터넷에서 사용하는 공인 IP 주소로 변환하는 기술 - 라우터 또는 방화벽에서 수행.
		○ NAT는 IP 주소를 1:1로 변환. LAN to WAN은 출발지 IP 주소를 변환. WAN to LAN은 목적지 IP 주소를 변환.
		○ NAPT는 사설 IP 주소와 공인 IP 주소를 N:1로 변환. LAN to WAN에서 출발지 IP 주소 뿐만 아니라, 출발지 포트 번호도 같이 변환.
			§ 라우터는 클라이언트의 출발지 IP 주소를 사설 IP에서 공인 IP로 변환. 동시에 출발지 포트 번호도 변환.
			§ 변환된 기억 정보 저장한 후에 데이터를 서버에게 전송.
			§ 서버에서 처리 결과를 클라이언트에게 되돌려주고, 반환되는 과정에서 라우터가 저장된 기억 정보를 바탕으로 원래대로 되돌려서 클라이언트에게 성공적으로 반환.

	3. 서버 준비하기
	• 서버 선택
		○ 어디에 있는 어떤 컴퓨터에 서버 SW를 설치할지 결정하는 것은 매우 중요한 문제(서버 확장성, 유지 보수성, 운용 관리성과 밀접).
		○ 시스템 구축 초기 단계에서 하는 하나하나의 선택이 시스템 전체의 미래를 결정. '장소'와 '종류'에 대한 기준으로 분류.
		○ 서버를 어디에 설치할 것인가? - 장소
			§ 운용 형태 : 온프레미스(On-Premise), 클라우드(Cloud), 임대 서버 운용.
			§ 설치 장소 : 자사 설치, 데이터 센터 설치.
		○ 어떤 서버를 설치할 것인가? - 종류
			§ 물리 서버의 형태 : 렉(Rack), 타워, 블레이드
			§ 가상화의 도입 : 가상 서버, 물리 서버
			§ 하드웨어 사양 : CPU, 메모리, 스토리지, NIC
			§ OS 종류 : Windows 계열 OS, UNIX 계열 OS
			§ 서비스제공 형태 : 어플라이언스 서버, 범용 서버
	• 온-프레미스 & 클라우드(On-Premise & Cloud)
		○ 자사에서 운영하는 온-프레미스형과 클라우드 서비스를 이용하는 클라우드형.
		○ 온-프레미스형 
			§ 네트워크 기기와 서버 모두 자사의 것이므로 자유롭게 구성.
			§ 트러블 발생 시 상황 파악이 쉬우며 트러블 슈팅을 하기 쉬움.
			§ 그러나 모든 설비를 조달해야 하고 비용과 운용까지의 시간이 오래 걸림.
		○ 클라우드형
			§ 클라우드 사업자의 설비에 시스템을 구축하므로 구축의 시간이 걸리지 않음.
			§ 사양 요건에 맞춰 사양을 쉽게 바꿀 수 있음.
			§ 그러나 클라우드라는 한정적인 조건과 문제 발생 시 클라우드 사업자에게 맡겨야하므로 트러블 슈팅의 문제 발생.
			§ 클라우드형의 단점이 서서히 부각. 대체제 : 하이브리드 클라우드형.
		○ 하이브리드 클라우드형
			§ 온-프레미스형과 클라우드형의 복합.
			§ 사내에 있는 온-프레미스 환경과 클라우드 사업자 안에 있는 클라우드 환경을 VPN으로 연결.
			§ 기존 시스템과 연계가 필요한 서버는 온-프레미스, 필요 없는 부분은 클라우드로 구성.
	• 클라우드 서비스의 종류
		○ 클라우드 서비스는 운용 관리 비용 절감과 구축 속도 향상 등의 장점.
		○ 종류 : IaaS, PaaS, SaaS.
		○ IaaS(Infrastructure as a Service) - 요청 후 필요한 애플리케이션 실행 환경을 직접 구축.
			§ CPU, 메모리, 스토리지 등과 같은 인프라를 제공하는 형태의 클라우드 서비스.
			§ 예) Amazon EC2, MS Azure.
			§ 시스템 관리자가 메모리와 스토리지의 용량, CPU와 OS의 종류를 선택하면 애플리케이션 SW가 설치되지 않은 빈 서버가 제공.
		○ PaaS(Platform as a Service) - 요청 후 미들웨어나 DB 등의 서비스는 직접 보수.
			§ IaaS의 확장판으로서, 애플리케이션을 가동하기 위한 플랫폼을 제공하는 형태의 클라우드 서비스.
			§ 예) SalesForce Force.com, MS Azure.
			§ IaaS의 인프라에 프로그래밍 언어와 DB 애플리케이션 등을 가동하기 위한 플랫폼을 제공.
		○ SaaS(Software as a Service) - 서버와 거기서 사용되는 DB 등의 플랫폼은 전혀 고려할 필요가 없음.
			§ 소프트웨어(서비스)를 제공하는 형태의 클라우드 서비스.
			§ 클라우드 내의 SW를 서비스로 이용.
			§ SaaS는 플랫폼 마저 고려할 필요 없으므로 관리 효율이 상승.
	• 자사 또는 데이터 센터
		○ 서버는 유지 보수 시를 제외하고 언제든지 이용할 수 있도록 가동할 필요가 있음. 따라서 물리적인 관점에서 트러블 대비.
		○ 물리적 트러블 예) 발열 대책, 전원 대책, 지진 대책, 보안 대책
		○ 자사 서버를 두는것과 데이터 센터를 운영하는 것은 각각의 장단점이 있음.
	• 서버 가상화
		○ 한 대의 서버를 많은 서버로 분할하여 이용하는 기술
		○ 장점
			§ 물리적으로 몇 개의 서버를 한 대의 서버에 집약 시킬 수 있으므로 설치 공간을 절약. 동시에 한 대로 운영할 경우 전력 절약.
			§ 다른 서버로 가상 머신을 이동시킬 수 있음. Live Migration : 물리 서버를 가동 시킨 상태에서 다른 물리 서버로 가상화 서버만 이동시킬 수 있음. Fault Tolerance : 장애 발생 시, 가상 서버의 복사본을 다른 물리 서버로 옮김.
		○ 단점
			§ 가상화 소프트웨어는 가상 머신에 여러가지 하드웨어 처리를 실행시키는 구조. 따라서 로컬 실행 서버와 비교하였을 때 퍼포먼스 저하가 있음.
			§ DB 서버와 같이 성능을 요구하는 서버나, NTP 서버와 같이 신속성을 요구하는 서버는 물리 서버로 구축할 것.
	• 가상화 SW의 종류
		○ 호스트 OS형
			§ 호스트 OS형은 보통의 OS에 인스톨한 가상화 SW에서 가상 머신을 작동시키는 가상화 기술.
			§ 가상 머신과 더불어 호스트 OS도 작동해야 하므로, 지연이 많기 때문에 실제 환경에서 사용은 부적합. 
			§ 즉, 보통의 PC에도 간단히 인스톨할 수 있으나, 동작이 무거움.
		○ 하이퍼바이저형 가상화 SW
			§ 하드웨어에 직접 인스톨한 가상화 소프트웨어에서 가상 머신을 작동 시키는 가상화 기술.
			§ 가상화 소프트웨어의 리소스만 사용하므로 지연이 적음. 따라서 실제 환경에서 사용.
			§ 즉, 하드웨어 상에서 직접 작동하므로 가상 머신이 경쾌하게 작동.
	• 서버의 케이스 모양
		○ 온프레미스형의 경우 어떤 하드웨어 서버에 소프트웨어를 인스톨할 지도 결정해야 함. SW만 설치하면 서버로서 동작할 수 있으나, 기밀 데이터의 내용을 가정용 PC 서버로 실행하는 것은 부담.
		○ 서버는 일반 PC와 달리 퍼포먼스와 신뢰성 향상을 도모하는 사양을 사용.
		○ 서버 케이스 모양 - 타워형, 랙형, 블레이트형
			§ 타워형 : PC와 유사한 모양이며 서버용으로 구성만 변경한 사양. 중소기업에서 사용.
			§ 랙형 : 전용 수납 랙이 정해져 있어서 1유닛의 크기를 1U라고 하며 대기업이나 데이터 센터에 활용.
			§ 타워형 : 랙형보다 더욱 고밀도로 서버를 배치할 수 있어서 마찬가지로 대기업이나 데이터 센터에 활용. 
	• 서버 구성 부품
		○ 서버는 CPU, 메모리, 스토리지, NIC로 구성되며 서버용으로 만들어진 전용 사양을 사용함으로써 퍼포먼스와 신뢰성의 향상을 도모.
		○ 부품의 서버용 업그레이드
			§ CPU : 과거 클럭수를 높이려고 했으나 현재는 멀티 코어화하여 성능 향상.
			§ 메모리 : OS의 64bit화와 함께 용량이 단숨에 증가. 오류 자동 수정 ECC 장치. 다중화를 위한 메모리 미러링 기능.
			§ 스토리지 : HDD, SSD 사용. 서버용 스토리지는 RAID 방법을 사용하여 다중 구성을 할 수 있어서 신뢰성 향상.
			§ NIC : Teaming 기법을 이용하여 대역을 늘리거나 다중화 시킴.
	• 서버 OS
		○ 일반 PC보다 안정적으로 작동시키기 위해 개발 및 저정된 OS를 서버 OS라고 함. 그래픽이나 음향 처리 같은 서비스를 배제함.
		○ UNIX 계열 서버 OS
			§ 서버 OS의 원조인 UNIX를 표준으로 하여 UNIX처럼 작동하도록 만든 서버 OS.
			§ 오픈소스 Linux 또는 IBM의 AIX등. 
			§ CLI 동작을 기본 원칙으로 함. 직관적이지 않지만 안정성을 확보할 수 있음. 또한 라이선스 관련 초기 비용 절감.
		○ Windows 계열 서버 OS
			§ MS사의 Windows 10과 같이 유료 버전의 OS.
			§ 라이선스를 사용하여 초기 비용이 부담될 수 있으나 GUI를 이용한 직관적 조작과 MS의 지원을 통한 안전성.
	• 어플라이언스 서버
		○ 특정 서비스나 기능만으로 특화 시켜 만든 서버를 어플라이언스 서버라고 함.
			§ 특정 서버 예) 웹 서버, DNS 서버, 프록시 서버, 방화벽 등.
		○ 도입도 간단하며 운용 관리도 쉽기 때문에 많은 기업에서 채택.
		○ 어플라이언스 서버는 OS 또는 애플리케이션이 설치된 상태로 출하되기 때문에 간편 도입 가능.
			§ 설정 마법사 등 운용 툴이 마련되어 있어서 설정이 용이하며, 고장 났을 경우 기기 교환으로 해결.
		○ 범용 서버 대비 불필요한 기능을 없앨 수 있으므로 비용을 절감할 수 있고 퍼포먼스를 향상.
		○ 그러나 설정 범위가 정해져 있으며, 하드웨어 구성도 특정 서버를 위해 최적화되어 있으므로 다른 용도로 사용 불가.
		
